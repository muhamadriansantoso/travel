import { OnInit, AfterContentChecked, OnDestroy, QueryList, TemplateRef, ElementRef, AfterContentInit, EventEmitter, ChangeDetectorRef } from '@angular/core';
import { Subscription } from 'rxjs';
import { ResizeService } from '../services/resize.service';
import { CarouselService } from '../services/carousel.service';
import { StageData } from "../models/stage-data.model";
import { OwlDOMData } from "../models/owlDOM-data.model";
import { SlideModel } from '../models/slide.model';
import { OwlOptions } from '../models/owl-options.model';
import { NavData, DotsData } from '../models/navigation-data.models';
import { NavigationService } from '../services/navigation.service';
import { AutoplayService } from '../services/autoplay.service';
import { LazyLoadService } from '../services/lazyload.service';
import { AnimateService } from '../services/animate.service';
import { AutoHeightService } from '../services/autoheight.service';
import { HashService } from '../services/hash.service';
import { OwlLogger } from '../services/logger.service';
import * as ɵngcc0 from '@angular/core';
export declare class CarouselSlideDirective {
    tplRef: TemplateRef<any>;
    /**
     * Unique slide identifier. Must be unique for the entire document for proper accessibility support.
     * Will be auto-generated if not provided.
     */
    id: string;
    /**
     * Defines how much widths of common slide will current slide have
     * e.g. if _mergeData=2, the slide will twice wider then slides with _mergeData=1
     */
    private _dataMerge;
    dataMerge: number;
    /**
     * Width of slide
     */
    width: number;
    /**
     * Inner content of dot for certain slide; can be html-markup
     */
    dotContent: string;
    /**
     * Hash (fragment) of url which corresponds to certain slide
     */
    dataHash: string;
    constructor(tplRef: TemplateRef<any>);
    /**
       * Determines if the input is a Number or something that can be coerced to a Number
       * @param - The input to be tested
       * @returns - An indication if the input is a Number or can be coerced to a Number
       */
    isNumeric(number: any): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CarouselSlideDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<CarouselSlideDirective, "ng-template[carouselSlide]", never, { "id": "id"; "width": "width"; "dotContent": "dotContent"; "dataHash": "dataHash"; "dataMerge": "dataMerge"; }, {}, never>;
}
/**
 * Data which will be passed out after ending of transition of carousel
 */
export declare class SlidesOutputData {
    startPosition?: number;
    slides?: SlideModel[];
}
export declare class CarouselComponent implements OnInit, AfterContentChecked, AfterContentInit, OnDestroy {
    private el;
    private resizeService;
    private carouselService;
    private navigationService;
    private autoplayService;
    private lazyLoadService;
    private animateService;
    private autoHeightService;
    private hashService;
    private logger;
    private changeDetectorRef;
    slides: QueryList<CarouselSlideDirective>;
    translated: EventEmitter<SlidesOutputData>;
    dragging: EventEmitter<{
        dragging: boolean;
        data: SlidesOutputData;
    }>;
    change: EventEmitter<SlidesOutputData>;
    changed: EventEmitter<SlidesOutputData>;
    initialized: EventEmitter<SlidesOutputData>;
    /**
     * Width of carousel window (tag with class .owl-carousel), in wich we can see moving sliders
     */
    carouselWindowWidth: number;
    /**
     * Subscription to 'resize' event
     */
    resizeSubscription: Subscription;
    /**
     * Subscription merge Observable, which merges all Observables in the component except 'resize' Observable and this.slides.changes()
     */
    private _allObservSubscription;
    /**
     * Subscription to `this.slides.changes().
     * It could be included in 'this._allObservSubscription', but that subcription get created during the initializing of component
     * and 'this.slides' are undefined at that moment. So it's needed to wait for initialization of content.
     */
    private _slidesChangesSubscription;
    /**
     * Current settings for the carousel.
     */
    owlDOMData: OwlDOMData;
    /**
     * Data of owl-stage
     */
    stageData: StageData;
    /**
       *  Data of every slide
       */
    slidesData: SlideModel[];
    /**
       * Data of navigation block
       */
    navData: NavData;
    /**
     * Data of dots block
     */
    dotsData: DotsData;
    /**
     * Data, wich are passed out of carousel after ending of transioning of carousel
     */
    slidesOutputData: SlidesOutputData;
    /**
     * Shows whether carousel is loaded of not.
     */
    carouselLoaded: boolean;
    /**
     * User's options
     */
    options: OwlOptions;
    /**
     * Observable for getting current View Settings
     */
    private _viewCurSettings$;
    /**
     * Observable for catching the end of transition of carousel
     */
    private _translatedCarousel$;
    /**
     * Observable for catching the start of dragging of the carousel
     */
    private _draggingCarousel$;
    /**
     * Observable for catching the start of changing of the carousel
     */
    private _changeCarousel$;
    /**
     * Observable for catching the moment when the data about slides changed, more exactly when the position changed.
     */
    private _changedCarousel$;
    /**
     * Observable for catching the initialization of changing the carousel
     */
    private _initializedCarousel$;
    /**
     * Observable for merging all Observables and creating one subscription
     */
    private _carouselMerge$;
    private docRef;
    constructor(el: ElementRef, resizeService: ResizeService, carouselService: CarouselService, navigationService: NavigationService, autoplayService: AutoplayService, lazyLoadService: LazyLoadService, animateService: AnimateService, autoHeightService: AutoHeightService, hashService: HashService, logger: OwlLogger, changeDetectorRef: ChangeDetectorRef, docRef: any);
    onVisibilityChange(ev: any): void;
    ngOnInit(): void;
    ngAfterContentChecked(): void;
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    /**
     * Joins the observable login in one place: sets values to some observables, merges this observables and
     * subcribes to merge func
     */
    spyDataStreams(): void;
    /**
     * Init subscription to resize event and attaches handler for this event
     */
    private _winResizeWatcher;
    /**
     * Handler for transitioend event
     */
    onTransitionEnd(): void;
    /**
     * Handler for click event, attached to next button
     */
    next(): void;
    /**
     * Handler for click event, attached to prev button
     */
    prev(): void;
    /**
     * Handler for click event, attached to dots
     */
    moveByDot(dotId: string): void;
    /**
     * rewinds carousel to slide with needed id
     * @param id fragment of url
     */
    to(id: string): void;
    /**
     * Gathers and prepares data intended for passing to the user by means of firing event translatedCarousel
     */
    gatherTranslatedData(): void;
    /**
     * Starts pausing
     */
    startPausing(): void;
    /**
     * Starts playing after mouse leaves carousel
     */
    startPlayML(): void;
    /**
     * Starts playing after touch ends
     */
    startPlayTE(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CarouselComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CarouselComponent, "owl-carousel-o", never, { "options": "options"; }, { "translated": "translated"; "dragging": "dragging"; "change": "change"; "changed": "changed"; "initialized": "initialized"; }, ["slides"], never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImNhcm91c2VsLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9uSW5pdCwgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgT25EZXN0cm95LCBRdWVyeUxpc3QsIFRlbXBsYXRlUmVmLCBFbGVtZW50UmVmLCBBZnRlckNvbnRlbnRJbml0LCBFdmVudEVtaXR0ZXIsIENoYW5nZURldGVjdG9yUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvcmVzaXplLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDYXJvdXNlbFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jYXJvdXNlbC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU3RhZ2VEYXRhIH0gZnJvbSBcIi4uL21vZGVscy9zdGFnZS1kYXRhLm1vZGVsXCI7XHJcbmltcG9ydCB7IE93bERPTURhdGEgfSBmcm9tIFwiLi4vbW9kZWxzL293bERPTS1kYXRhLm1vZGVsXCI7XHJcbmltcG9ydCB7IFNsaWRlTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvc2xpZGUubW9kZWwnO1xyXG5pbXBvcnQgeyBPd2xPcHRpb25zIH0gZnJvbSAnLi4vbW9kZWxzL293bC1vcHRpb25zLm1vZGVsJztcclxuaW1wb3J0IHsgTmF2RGF0YSwgRG90c0RhdGEgfSBmcm9tICcuLi9tb2RlbHMvbmF2aWdhdGlvbi1kYXRhLm1vZGVscyc7XHJcbmltcG9ydCB7IE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbmF2aWdhdGlvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQXV0b3BsYXlTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvYXV0b3BsYXkuc2VydmljZSc7XHJcbmltcG9ydCB7IExhenlMb2FkU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2xhenlsb2FkLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBBbmltYXRlU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuaW1hdGUuc2VydmljZSc7XHJcbmltcG9ydCB7IEF1dG9IZWlnaHRTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvYXV0b2hlaWdodC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSGFzaFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9oYXNoLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBPd2xMb2dnZXIgfSBmcm9tICcuLi9zZXJ2aWNlcy9sb2dnZXIuc2VydmljZSc7XHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENhcm91c2VsU2xpZGVEaXJlY3RpdmUge1xyXG4gICAgdHBsUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmlxdWUgc2xpZGUgaWRlbnRpZmllci4gTXVzdCBiZSB1bmlxdWUgZm9yIHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9yIHByb3BlciBhY2Nlc3NpYmlsaXR5IHN1cHBvcnQuXHJcbiAgICAgKiBXaWxsIGJlIGF1dG8tZ2VuZXJhdGVkIGlmIG5vdCBwcm92aWRlZC5cclxuICAgICAqL1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBob3cgbXVjaCB3aWR0aHMgb2YgY29tbW9uIHNsaWRlIHdpbGwgY3VycmVudCBzbGlkZSBoYXZlXHJcbiAgICAgKiBlLmcuIGlmIF9tZXJnZURhdGE9MiwgdGhlIHNsaWRlIHdpbGwgdHdpY2Ugd2lkZXIgdGhlbiBzbGlkZXMgd2l0aCBfbWVyZ2VEYXRhPTFcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZGF0YU1lcmdlO1xyXG4gICAgZGF0YU1lcmdlOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFdpZHRoIG9mIHNsaWRlXHJcbiAgICAgKi9cclxuICAgIHdpZHRoOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIElubmVyIGNvbnRlbnQgb2YgZG90IGZvciBjZXJ0YWluIHNsaWRlOyBjYW4gYmUgaHRtbC1tYXJrdXBcclxuICAgICAqL1xyXG4gICAgZG90Q29udGVudDogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYXNoIChmcmFnbWVudCkgb2YgdXJsIHdoaWNoIGNvcnJlc3BvbmRzIHRvIGNlcnRhaW4gc2xpZGVcclxuICAgICAqL1xyXG4gICAgZGF0YUhhc2g6IHN0cmluZztcclxuICAgIGNvbnN0cnVjdG9yKHRwbFJlZjogVGVtcGxhdGVSZWY8YW55Pik7XHJcbiAgICAvKipcclxuICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBOdW1iZXIgb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gYSBOdW1iZXJcclxuICAgICAgICogQHBhcmFtIC0gVGhlIGlucHV0IHRvIGJlIHRlc3RlZFxyXG4gICAgICAgKiBAcmV0dXJucyAtIEFuIGluZGljYXRpb24gaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXHJcbiAgICAgICAqL1xyXG4gICAgaXNOdW1lcmljKG51bWJlcjogYW55KTogYm9vbGVhbjtcclxufVxyXG4vKipcclxuICogRGF0YSB3aGljaCB3aWxsIGJlIHBhc3NlZCBvdXQgYWZ0ZXIgZW5kaW5nIG9mIHRyYW5zaXRpb24gb2YgY2Fyb3VzZWxcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIFNsaWRlc091dHB1dERhdGEge1xyXG4gICAgc3RhcnRQb3NpdGlvbj86IG51bWJlcjtcclxuICAgIHNsaWRlcz86IFNsaWRlTW9kZWxbXTtcclxufVxyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDYXJvdXNlbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcclxuICAgIHByaXZhdGUgZWw7XHJcbiAgICBwcml2YXRlIHJlc2l6ZVNlcnZpY2U7XHJcbiAgICBwcml2YXRlIGNhcm91c2VsU2VydmljZTtcclxuICAgIHByaXZhdGUgbmF2aWdhdGlvblNlcnZpY2U7XHJcbiAgICBwcml2YXRlIGF1dG9wbGF5U2VydmljZTtcclxuICAgIHByaXZhdGUgbGF6eUxvYWRTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBhbmltYXRlU2VydmljZTtcclxuICAgIHByaXZhdGUgYXV0b0hlaWdodFNlcnZpY2U7XHJcbiAgICBwcml2YXRlIGhhc2hTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBsb2dnZXI7XHJcbiAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmO1xyXG4gICAgc2xpZGVzOiBRdWVyeUxpc3Q8Q2Fyb3VzZWxTbGlkZURpcmVjdGl2ZT47XHJcbiAgICB0cmFuc2xhdGVkOiBFdmVudEVtaXR0ZXI8U2xpZGVzT3V0cHV0RGF0YT47XHJcbiAgICBkcmFnZ2luZzogRXZlbnRFbWl0dGVyPHtcclxuICAgICAgICBkcmFnZ2luZzogYm9vbGVhbjtcclxuICAgICAgICBkYXRhOiBTbGlkZXNPdXRwdXREYXRhO1xyXG4gICAgfT47XHJcbiAgICBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxTbGlkZXNPdXRwdXREYXRhPjtcclxuICAgIGNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxTbGlkZXNPdXRwdXREYXRhPjtcclxuICAgIGluaXRpYWxpemVkOiBFdmVudEVtaXR0ZXI8U2xpZGVzT3V0cHV0RGF0YT47XHJcbiAgICAvKipcclxuICAgICAqIFdpZHRoIG9mIGNhcm91c2VsIHdpbmRvdyAodGFnIHdpdGggY2xhc3MgLm93bC1jYXJvdXNlbCksIGluIHdpY2ggd2UgY2FuIHNlZSBtb3Zpbmcgc2xpZGVyc1xyXG4gICAgICovXHJcbiAgICBjYXJvdXNlbFdpbmRvd1dpZHRoOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmlwdGlvbiB0byAncmVzaXplJyBldmVudFxyXG4gICAgICovXHJcbiAgICByZXNpemVTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaXB0aW9uIG1lcmdlIE9ic2VydmFibGUsIHdoaWNoIG1lcmdlcyBhbGwgT2JzZXJ2YWJsZXMgaW4gdGhlIGNvbXBvbmVudCBleGNlcHQgJ3Jlc2l6ZScgT2JzZXJ2YWJsZSBhbmQgdGhpcy5zbGlkZXMuY2hhbmdlcygpXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2FsbE9ic2VydlN1YnNjcmlwdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaXB0aW9uIHRvIGB0aGlzLnNsaWRlcy5jaGFuZ2VzKCkuXHJcbiAgICAgKiBJdCBjb3VsZCBiZSBpbmNsdWRlZCBpbiAndGhpcy5fYWxsT2JzZXJ2U3Vic2NyaXB0aW9uJywgYnV0IHRoYXQgc3ViY3JpcHRpb24gZ2V0IGNyZWF0ZWQgZHVyaW5nIHRoZSBpbml0aWFsaXppbmcgb2YgY29tcG9uZW50XHJcbiAgICAgKiBhbmQgJ3RoaXMuc2xpZGVzJyBhcmUgdW5kZWZpbmVkIGF0IHRoYXQgbW9tZW50LiBTbyBpdCdzIG5lZWRlZCB0byB3YWl0IGZvciBpbml0aWFsaXphdGlvbiBvZiBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9zbGlkZXNDaGFuZ2VzU3Vic2NyaXB0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHNldHRpbmdzIGZvciB0aGUgY2Fyb3VzZWwuXHJcbiAgICAgKi9cclxuICAgIG93bERPTURhdGE6IE93bERPTURhdGE7XHJcbiAgICAvKipcclxuICAgICAqIERhdGEgb2Ygb3dsLXN0YWdlXHJcbiAgICAgKi9cclxuICAgIHN0YWdlRGF0YTogU3RhZ2VEYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgICAqICBEYXRhIG9mIGV2ZXJ5IHNsaWRlXHJcbiAgICAgICAqL1xyXG4gICAgc2xpZGVzRGF0YTogU2xpZGVNb2RlbFtdO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIERhdGEgb2YgbmF2aWdhdGlvbiBibG9ja1xyXG4gICAgICAgKi9cclxuICAgIG5hdkRhdGE6IE5hdkRhdGE7XHJcbiAgICAvKipcclxuICAgICAqIERhdGEgb2YgZG90cyBibG9ja1xyXG4gICAgICovXHJcbiAgICBkb3RzRGF0YTogRG90c0RhdGE7XHJcbiAgICAvKipcclxuICAgICAqIERhdGEsIHdpY2ggYXJlIHBhc3NlZCBvdXQgb2YgY2Fyb3VzZWwgYWZ0ZXIgZW5kaW5nIG9mIHRyYW5zaW9uaW5nIG9mIGNhcm91c2VsXHJcbiAgICAgKi9cclxuICAgIHNsaWRlc091dHB1dERhdGE6IFNsaWRlc091dHB1dERhdGE7XHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHdoZXRoZXIgY2Fyb3VzZWwgaXMgbG9hZGVkIG9mIG5vdC5cclxuICAgICAqL1xyXG4gICAgY2Fyb3VzZWxMb2FkZWQ6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFVzZXIncyBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIG9wdGlvbnM6IE93bE9wdGlvbnM7XHJcbiAgICAvKipcclxuICAgICAqIE9ic2VydmFibGUgZm9yIGdldHRpbmcgY3VycmVudCBWaWV3IFNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3ZpZXdDdXJTZXR0aW5ncyQ7XHJcbiAgICAvKipcclxuICAgICAqIE9ic2VydmFibGUgZm9yIGNhdGNoaW5nIHRoZSBlbmQgb2YgdHJhbnNpdGlvbiBvZiBjYXJvdXNlbFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF90cmFuc2xhdGVkQ2Fyb3VzZWwkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIGZvciBjYXRjaGluZyB0aGUgc3RhcnQgb2YgZHJhZ2dpbmcgb2YgdGhlIGNhcm91c2VsXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2RyYWdnaW5nQ2Fyb3VzZWwkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPYnNlcnZhYmxlIGZvciBjYXRjaGluZyB0aGUgc3RhcnQgb2YgY2hhbmdpbmcgb2YgdGhlIGNhcm91c2VsXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2NoYW5nZUNhcm91c2VsJDtcclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2YWJsZSBmb3IgY2F0Y2hpbmcgdGhlIG1vbWVudCB3aGVuIHRoZSBkYXRhIGFib3V0IHNsaWRlcyBjaGFuZ2VkLCBtb3JlIGV4YWN0bHkgd2hlbiB0aGUgcG9zaXRpb24gY2hhbmdlZC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfY2hhbmdlZENhcm91c2VsJDtcclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2YWJsZSBmb3IgY2F0Y2hpbmcgdGhlIGluaXRpYWxpemF0aW9uIG9mIGNoYW5naW5nIHRoZSBjYXJvdXNlbFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9pbml0aWFsaXplZENhcm91c2VsJDtcclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2YWJsZSBmb3IgbWVyZ2luZyBhbGwgT2JzZXJ2YWJsZXMgYW5kIGNyZWF0aW5nIG9uZSBzdWJzY3JpcHRpb25cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfY2Fyb3VzZWxNZXJnZSQ7XHJcbiAgICBwcml2YXRlIGRvY1JlZjtcclxuICAgIGNvbnN0cnVjdG9yKGVsOiBFbGVtZW50UmVmLCByZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlLCBjYXJvdXNlbFNlcnZpY2U6IENhcm91c2VsU2VydmljZSwgbmF2aWdhdGlvblNlcnZpY2U6IE5hdmlnYXRpb25TZXJ2aWNlLCBhdXRvcGxheVNlcnZpY2U6IEF1dG9wbGF5U2VydmljZSwgbGF6eUxvYWRTZXJ2aWNlOiBMYXp5TG9hZFNlcnZpY2UsIGFuaW1hdGVTZXJ2aWNlOiBBbmltYXRlU2VydmljZSwgYXV0b0hlaWdodFNlcnZpY2U6IEF1dG9IZWlnaHRTZXJ2aWNlLCBoYXNoU2VydmljZTogSGFzaFNlcnZpY2UsIGxvZ2dlcjogT3dsTG9nZ2VyLCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIGRvY1JlZjogYW55KTtcclxuICAgIG9uVmlzaWJpbGl0eUNoYW5nZShldjogYW55KTogdm9pZDtcclxuICAgIG5nT25Jbml0KCk6IHZvaWQ7XHJcbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKTogdm9pZDtcclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogSm9pbnMgdGhlIG9ic2VydmFibGUgbG9naW4gaW4gb25lIHBsYWNlOiBzZXRzIHZhbHVlcyB0byBzb21lIG9ic2VydmFibGVzLCBtZXJnZXMgdGhpcyBvYnNlcnZhYmxlcyBhbmRcclxuICAgICAqIHN1YmNyaWJlcyB0byBtZXJnZSBmdW5jXHJcbiAgICAgKi9cclxuICAgIHNweURhdGFTdHJlYW1zKCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEluaXQgc3Vic2NyaXB0aW9uIHRvIHJlc2l6ZSBldmVudCBhbmQgYXR0YWNoZXMgaGFuZGxlciBmb3IgdGhpcyBldmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF93aW5SZXNpemVXYXRjaGVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciB0cmFuc2l0aW9lbmQgZXZlbnRcclxuICAgICAqL1xyXG4gICAgb25UcmFuc2l0aW9uRW5kKCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yIGNsaWNrIGV2ZW50LCBhdHRhY2hlZCB0byBuZXh0IGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBuZXh0KCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yIGNsaWNrIGV2ZW50LCBhdHRhY2hlZCB0byBwcmV2IGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBwcmV2KCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yIGNsaWNrIGV2ZW50LCBhdHRhY2hlZCB0byBkb3RzXHJcbiAgICAgKi9cclxuICAgIG1vdmVCeURvdChkb3RJZDogc3RyaW5nKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogcmV3aW5kcyBjYXJvdXNlbCB0byBzbGlkZSB3aXRoIG5lZWRlZCBpZFxyXG4gICAgICogQHBhcmFtIGlkIGZyYWdtZW50IG9mIHVybFxyXG4gICAgICovXHJcbiAgICB0byhpZDogc3RyaW5nKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogR2F0aGVycyBhbmQgcHJlcGFyZXMgZGF0YSBpbnRlbmRlZCBmb3IgcGFzc2luZyB0byB0aGUgdXNlciBieSBtZWFucyBvZiBmaXJpbmcgZXZlbnQgdHJhbnNsYXRlZENhcm91c2VsXHJcbiAgICAgKi9cclxuICAgIGdhdGhlclRyYW5zbGF0ZWREYXRhKCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBwYXVzaW5nXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0UGF1c2luZygpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgcGxheWluZyBhZnRlciBtb3VzZSBsZWF2ZXMgY2Fyb3VzZWxcclxuICAgICAqL1xyXG4gICAgc3RhcnRQbGF5TUwoKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHBsYXlpbmcgYWZ0ZXIgdG91Y2ggZW5kc1xyXG4gICAgICovXHJcbiAgICBzdGFydFBsYXlURSgpOiB2b2lkO1xyXG59XHJcbiJdfQ==