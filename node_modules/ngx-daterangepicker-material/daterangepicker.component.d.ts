import { OnInit, ElementRef, EventEmitter, ChangeDetectorRef } from '@angular/core';
import { FormControl } from '@angular/forms';
import { LocaleConfig } from './daterangepicker.config';
import * as _moment from 'moment';
import { LocaleService } from './locale.service';
import * as ɵngcc0 from '@angular/core';
export declare enum SideEnum {
    left = "left",
    right = "right"
}
export declare class DaterangepickerComponent implements OnInit {
    private el;
    private _ref;
    private _localeService;
    private _old;
    chosenLabel: string;
    calendarVariables: {
        left: any;
        right: any;
    };
    tooltiptext: any[];
    timepickerVariables: {
        left: any;
        right: any;
    };
    daterangepicker: {
        start: FormControl;
        end: FormControl;
    };
    applyBtn: {
        disabled: boolean;
    };
    startDate: _moment.Moment;
    endDate: _moment.Moment;
    dateLimit: number;
    sideEnum: typeof SideEnum;
    minDate: _moment.Moment;
    maxDate: _moment.Moment;
    autoApply: Boolean;
    singleDatePicker: Boolean;
    showDropdowns: Boolean;
    showWeekNumbers: Boolean;
    showISOWeekNumbers: Boolean;
    linkedCalendars: Boolean;
    autoUpdateInput: Boolean;
    alwaysShowCalendars: Boolean;
    maxSpan: Boolean;
    lockStartDate: Boolean;
    timePicker: Boolean;
    timePicker24Hour: Boolean;
    timePickerIncrement: number;
    timePickerSeconds: Boolean;
    showClearButton: Boolean;
    firstMonthDayClass: string;
    lastMonthDayClass: string;
    emptyWeekRowClass: string;
    firstDayOfNextMonthClass: string;
    lastDayOfPreviousMonthClass: string;
    _locale: LocaleConfig;
    locale: any;
    _ranges: any;
    ranges: any;
    showCustomRangeLabel: boolean;
    showCancel: boolean;
    keepCalendarOpeningWithRange: boolean;
    showRangeLabelOnInput: boolean;
    customRangeDirection: boolean;
    chosenRange: string;
    rangesArray: Array<any>;
    isShown: Boolean;
    inline: boolean;
    leftCalendar: any;
    rightCalendar: any;
    showCalInRanges: Boolean;
    options: any;
    drops: string;
    opens: string;
    closeOnAutoApply: boolean;
    choosedDate: EventEmitter<Object>;
    rangeClicked: EventEmitter<Object>;
    datesUpdated: EventEmitter<Object>;
    startDateChanged: EventEmitter<Object>;
    endDateChanged: EventEmitter<Object>;
    pickerContainer: ElementRef;
    constructor(el: ElementRef, _ref: ChangeDetectorRef, _localeService: LocaleService);
    ngOnInit(): void;
    renderRanges(): void;
    renderTimePicker(side: SideEnum): void;
    renderCalendar(side: SideEnum): void;
    setStartDate(startDate: any): void;
    setEndDate(endDate: any): void;
    isInvalidDate(date: any): boolean;
    isCustomDate(date: any): boolean;
    isTooltipDate(date: any): string;
    updateView(): void;
    updateMonthsInView(): void;
    /**
     *  This is responsible for updating the calendars
     */
    updateCalendars(): void;
    updateElement(): void;
    remove(): void;
    /**
     * this should calculate the label
     */
    calculateChosenLabel(): void;
    clickApply(e?: any): void;
    clickCancel(e: any): void;
    /**
     * called when month is changed
     * @param monthEvent get value in event.target.value
     * @param side left or right
     */
    monthChanged(monthEvent: any, side: SideEnum): void;
    /**
     * called when year is changed
     * @param yearEvent get value in event.target.value
     * @param side left or right
     */
    yearChanged(yearEvent: any, side: SideEnum): void;
    /**
     * called when time is changed
     * @param timeEvent  an event
     * @param side left or right
     */
    timeChanged(timeEvent: any, side: SideEnum): void;
    /**
     *  call when month or year changed
     * @param month month number 0 -11
     * @param year year eg: 1995
     * @param side left or right
     */
    monthOrYearChanged(month: number, year: number, side: SideEnum): void;
    /**
     * Click on previous month
     * @param side left or right calendar
     */
    clickPrev(side: SideEnum): void;
    /**
     * Click on next month
     * @param side left or right calendar
     */
    clickNext(side: SideEnum): void;
    /**
     * When hovering a date
     * @param e event: get value by e.target.value
     * @param side left or right
     * @param row row position of the current date clicked
     * @param col col position of the current date clicked
     */
    hoverDate(e: any, side: SideEnum, row: number, col: number): void;
    /**
     * When selecting a date
     * @param e event: get value by e.target.value
     * @param side left or right
     * @param row row position of the current date clicked
     * @param col col position of the current date clicked
     */
    clickDate(e: any, side: SideEnum, row: number, col: number): void;
    /**
     *  Click on the custom range
     * @param e: Event
     * @param label
     */
    clickRange(e: any, label: any): void;
    show(e?: any): void;
    hide(e?: any): void;
    /**
     * handle click on all element in the component, useful for outside of click
     * @param e event
     */
    handleInternalClick(e: any): void;
    /**
     * update the locale options
     * @param locale
     */
    updateLocale(locale: any): void;
    /**
     *  clear the daterange picker
     */
    clear(): void;
    /**
     * Find out if the selected range should be disabled if it doesn't
     * fit into minDate and maxDate limitations.
     */
    disableRange(range: any): any;
    /**
     *
     * @param date the date to add time
     * @param side left or right
     */
    private _getDateWithTime;
    /**
     *  build the locale config
     */
    private _buildLocale;
    private _buildCells;
    /**
     * Find out if the current calendar row has current month days
     * (as opposed to consisting of only previous/next month days)
     */
    hasCurrentMonthDays(currentMonth: any, row: any): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DaterangepickerComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DaterangepickerComponent, "ngx-daterangepicker-material", never, { "startDate": "startDate"; "endDate": "endDate"; "dateLimit": "dateLimit"; "minDate": "minDate"; "maxDate": "maxDate"; "autoApply": "autoApply"; "singleDatePicker": "singleDatePicker"; "showDropdowns": "showDropdowns"; "showWeekNumbers": "showWeekNumbers"; "showISOWeekNumbers": "showISOWeekNumbers"; "linkedCalendars": "linkedCalendars"; "autoUpdateInput": "autoUpdateInput"; "alwaysShowCalendars": "alwaysShowCalendars"; "maxSpan": "maxSpan"; "lockStartDate": "lockStartDate"; "timePicker": "timePicker"; "timePicker24Hour": "timePicker24Hour"; "timePickerIncrement": "timePickerIncrement"; "timePickerSeconds": "timePickerSeconds"; "showClearButton": "showClearButton"; "firstMonthDayClass": "firstMonthDayClass"; "lastMonthDayClass": "lastMonthDayClass"; "emptyWeekRowClass": "emptyWeekRowClass"; "firstDayOfNextMonthClass": "firstDayOfNextMonthClass"; "lastDayOfPreviousMonthClass": "lastDayOfPreviousMonthClass"; "showCancel": "showCancel"; "keepCalendarOpeningWithRange": "keepCalendarOpeningWithRange"; "showRangeLabelOnInput": "showRangeLabelOnInput"; "customRangeDirection": "customRangeDirection"; "closeOnAutoApply": "closeOnAutoApply"; "locale": "locale"; "ranges": "ranges"; "isInvalidDate": "isInvalidDate"; "isCustomDate": "isCustomDate"; "isTooltipDate": "isTooltipDate"; "showCustomRangeLabel": "showCustomRangeLabel"; "drops": "drops"; "opens": "opens"; }, { "choosedDate": "choosedDate"; "rangeClicked": "rangeClicked"; "datesUpdated": "datesUpdated"; "startDateChanged": "startDateChanged"; "endDateChanged": "endDateChanged"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXJhbmdlcGlja2VyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJkYXRlcmFuZ2VwaWNrZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPbkluaXQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTG9jYWxlQ29uZmlnIH0gZnJvbSAnLi9kYXRlcmFuZ2VwaWNrZXIuY29uZmlnJztcbmltcG9ydCAqIGFzIF9tb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IExvY2FsZVNlcnZpY2UgfSBmcm9tICcuL2xvY2FsZS5zZXJ2aWNlJztcbmV4cG9ydCBkZWNsYXJlIGVudW0gU2lkZUVudW0ge1xuICAgIGxlZnQgPSBcImxlZnRcIixcbiAgICByaWdodCA9IFwicmlnaHRcIlxufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRGF0ZXJhbmdlcGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBwcml2YXRlIGVsO1xuICAgIHByaXZhdGUgX3JlZjtcbiAgICBwcml2YXRlIF9sb2NhbGVTZXJ2aWNlO1xuICAgIHByaXZhdGUgX29sZDtcbiAgICBjaG9zZW5MYWJlbDogc3RyaW5nO1xuICAgIGNhbGVuZGFyVmFyaWFibGVzOiB7XG4gICAgICAgIGxlZnQ6IGFueTtcbiAgICAgICAgcmlnaHQ6IGFueTtcbiAgICB9O1xuICAgIHRvb2x0aXB0ZXh0OiBhbnlbXTtcbiAgICB0aW1lcGlja2VyVmFyaWFibGVzOiB7XG4gICAgICAgIGxlZnQ6IGFueTtcbiAgICAgICAgcmlnaHQ6IGFueTtcbiAgICB9O1xuICAgIGRhdGVyYW5nZXBpY2tlcjoge1xuICAgICAgICBzdGFydDogRm9ybUNvbnRyb2w7XG4gICAgICAgIGVuZDogRm9ybUNvbnRyb2w7XG4gICAgfTtcbiAgICBhcHBseUJ0bjoge1xuICAgICAgICBkaXNhYmxlZDogYm9vbGVhbjtcbiAgICB9O1xuICAgIHN0YXJ0RGF0ZTogX21vbWVudC5Nb21lbnQ7XG4gICAgZW5kRGF0ZTogX21vbWVudC5Nb21lbnQ7XG4gICAgZGF0ZUxpbWl0OiBudW1iZXI7XG4gICAgc2lkZUVudW06IHR5cGVvZiBTaWRlRW51bTtcbiAgICBtaW5EYXRlOiBfbW9tZW50Lk1vbWVudDtcbiAgICBtYXhEYXRlOiBfbW9tZW50Lk1vbWVudDtcbiAgICBhdXRvQXBwbHk6IEJvb2xlYW47XG4gICAgc2luZ2xlRGF0ZVBpY2tlcjogQm9vbGVhbjtcbiAgICBzaG93RHJvcGRvd25zOiBCb29sZWFuO1xuICAgIHNob3dXZWVrTnVtYmVyczogQm9vbGVhbjtcbiAgICBzaG93SVNPV2Vla051bWJlcnM6IEJvb2xlYW47XG4gICAgbGlua2VkQ2FsZW5kYXJzOiBCb29sZWFuO1xuICAgIGF1dG9VcGRhdGVJbnB1dDogQm9vbGVhbjtcbiAgICBhbHdheXNTaG93Q2FsZW5kYXJzOiBCb29sZWFuO1xuICAgIG1heFNwYW46IEJvb2xlYW47XG4gICAgbG9ja1N0YXJ0RGF0ZTogQm9vbGVhbjtcbiAgICB0aW1lUGlja2VyOiBCb29sZWFuO1xuICAgIHRpbWVQaWNrZXIyNEhvdXI6IEJvb2xlYW47XG4gICAgdGltZVBpY2tlckluY3JlbWVudDogbnVtYmVyO1xuICAgIHRpbWVQaWNrZXJTZWNvbmRzOiBCb29sZWFuO1xuICAgIHNob3dDbGVhckJ1dHRvbjogQm9vbGVhbjtcbiAgICBmaXJzdE1vbnRoRGF5Q2xhc3M6IHN0cmluZztcbiAgICBsYXN0TW9udGhEYXlDbGFzczogc3RyaW5nO1xuICAgIGVtcHR5V2Vla1Jvd0NsYXNzOiBzdHJpbmc7XG4gICAgZmlyc3REYXlPZk5leHRNb250aENsYXNzOiBzdHJpbmc7XG4gICAgbGFzdERheU9mUHJldmlvdXNNb250aENsYXNzOiBzdHJpbmc7XG4gICAgX2xvY2FsZTogTG9jYWxlQ29uZmlnO1xuICAgIGxvY2FsZTogYW55O1xuICAgIF9yYW5nZXM6IGFueTtcbiAgICByYW5nZXM6IGFueTtcbiAgICBzaG93Q3VzdG9tUmFuZ2VMYWJlbDogYm9vbGVhbjtcbiAgICBzaG93Q2FuY2VsOiBib29sZWFuO1xuICAgIGtlZXBDYWxlbmRhck9wZW5pbmdXaXRoUmFuZ2U6IGJvb2xlYW47XG4gICAgc2hvd1JhbmdlTGFiZWxPbklucHV0OiBib29sZWFuO1xuICAgIGN1c3RvbVJhbmdlRGlyZWN0aW9uOiBib29sZWFuO1xuICAgIGNob3NlblJhbmdlOiBzdHJpbmc7XG4gICAgcmFuZ2VzQXJyYXk6IEFycmF5PGFueT47XG4gICAgaXNTaG93bjogQm9vbGVhbjtcbiAgICBpbmxpbmU6IGJvb2xlYW47XG4gICAgbGVmdENhbGVuZGFyOiBhbnk7XG4gICAgcmlnaHRDYWxlbmRhcjogYW55O1xuICAgIHNob3dDYWxJblJhbmdlczogQm9vbGVhbjtcbiAgICBvcHRpb25zOiBhbnk7XG4gICAgZHJvcHM6IHN0cmluZztcbiAgICBvcGVuczogc3RyaW5nO1xuICAgIGNsb3NlT25BdXRvQXBwbHk6IGJvb2xlYW47XG4gICAgY2hvb3NlZERhdGU6IEV2ZW50RW1pdHRlcjxPYmplY3Q+O1xuICAgIHJhbmdlQ2xpY2tlZDogRXZlbnRFbWl0dGVyPE9iamVjdD47XG4gICAgZGF0ZXNVcGRhdGVkOiBFdmVudEVtaXR0ZXI8T2JqZWN0PjtcbiAgICBzdGFydERhdGVDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8T2JqZWN0PjtcbiAgICBlbmREYXRlQ2hhbmdlZDogRXZlbnRFbWl0dGVyPE9iamVjdD47XG4gICAgcGlja2VyQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuICAgIGNvbnN0cnVjdG9yKGVsOiBFbGVtZW50UmVmLCBfcmVmOiBDaGFuZ2VEZXRlY3RvclJlZiwgX2xvY2FsZVNlcnZpY2U6IExvY2FsZVNlcnZpY2UpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgcmVuZGVyUmFuZ2VzKCk6IHZvaWQ7XG4gICAgcmVuZGVyVGltZVBpY2tlcihzaWRlOiBTaWRlRW51bSk6IHZvaWQ7XG4gICAgcmVuZGVyQ2FsZW5kYXIoc2lkZTogU2lkZUVudW0pOiB2b2lkO1xuICAgIHNldFN0YXJ0RGF0ZShzdGFydERhdGU6IGFueSk6IHZvaWQ7XG4gICAgc2V0RW5kRGF0ZShlbmREYXRlOiBhbnkpOiB2b2lkO1xuICAgIGlzSW52YWxpZERhdGUoZGF0ZTogYW55KTogYm9vbGVhbjtcbiAgICBpc0N1c3RvbURhdGUoZGF0ZTogYW55KTogYm9vbGVhbjtcbiAgICBpc1Rvb2x0aXBEYXRlKGRhdGU6IGFueSk6IHN0cmluZztcbiAgICB1cGRhdGVWaWV3KCk6IHZvaWQ7XG4gICAgdXBkYXRlTW9udGhzSW5WaWV3KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogIFRoaXMgaXMgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIHRoZSBjYWxlbmRhcnNcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxlbmRhcnMoKTogdm9pZDtcbiAgICB1cGRhdGVFbGVtZW50KCk6IHZvaWQ7XG4gICAgcmVtb3ZlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogdGhpcyBzaG91bGQgY2FsY3VsYXRlIHRoZSBsYWJlbFxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUNob3NlbkxhYmVsKCk6IHZvaWQ7XG4gICAgY2xpY2tBcHBseShlPzogYW55KTogdm9pZDtcbiAgICBjbGlja0NhbmNlbChlOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIG1vbnRoIGlzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0gbW9udGhFdmVudCBnZXQgdmFsdWUgaW4gZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICogQHBhcmFtIHNpZGUgbGVmdCBvciByaWdodFxuICAgICAqL1xuICAgIG1vbnRoQ2hhbmdlZChtb250aEV2ZW50OiBhbnksIHNpZGU6IFNpZGVFbnVtKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB5ZWFyIGlzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0geWVhckV2ZW50IGdldCB2YWx1ZSBpbiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgKiBAcGFyYW0gc2lkZSBsZWZ0IG9yIHJpZ2h0XG4gICAgICovXG4gICAgeWVhckNoYW5nZWQoeWVhckV2ZW50OiBhbnksIHNpZGU6IFNpZGVFbnVtKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB0aW1lIGlzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0gdGltZUV2ZW50ICBhbiBldmVudFxuICAgICAqIEBwYXJhbSBzaWRlIGxlZnQgb3IgcmlnaHRcbiAgICAgKi9cbiAgICB0aW1lQ2hhbmdlZCh0aW1lRXZlbnQ6IGFueSwgc2lkZTogU2lkZUVudW0pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqICBjYWxsIHdoZW4gbW9udGggb3IgeWVhciBjaGFuZ2VkXG4gICAgICogQHBhcmFtIG1vbnRoIG1vbnRoIG51bWJlciAwIC0xMVxuICAgICAqIEBwYXJhbSB5ZWFyIHllYXIgZWc6IDE5OTVcbiAgICAgKiBAcGFyYW0gc2lkZSBsZWZ0IG9yIHJpZ2h0XG4gICAgICovXG4gICAgbW9udGhPclllYXJDaGFuZ2VkKG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlciwgc2lkZTogU2lkZUVudW0pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENsaWNrIG9uIHByZXZpb3VzIG1vbnRoXG4gICAgICogQHBhcmFtIHNpZGUgbGVmdCBvciByaWdodCBjYWxlbmRhclxuICAgICAqL1xuICAgIGNsaWNrUHJldihzaWRlOiBTaWRlRW51bSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xpY2sgb24gbmV4dCBtb250aFxuICAgICAqIEBwYXJhbSBzaWRlIGxlZnQgb3IgcmlnaHQgY2FsZW5kYXJcbiAgICAgKi9cbiAgICBjbGlja05leHQoc2lkZTogU2lkZUVudW0pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFdoZW4gaG92ZXJpbmcgYSBkYXRlXG4gICAgICogQHBhcmFtIGUgZXZlbnQ6IGdldCB2YWx1ZSBieSBlLnRhcmdldC52YWx1ZVxuICAgICAqIEBwYXJhbSBzaWRlIGxlZnQgb3IgcmlnaHRcbiAgICAgKiBAcGFyYW0gcm93IHJvdyBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBkYXRlIGNsaWNrZWRcbiAgICAgKiBAcGFyYW0gY29sIGNvbCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBkYXRlIGNsaWNrZWRcbiAgICAgKi9cbiAgICBob3ZlckRhdGUoZTogYW55LCBzaWRlOiBTaWRlRW51bSwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBXaGVuIHNlbGVjdGluZyBhIGRhdGVcbiAgICAgKiBAcGFyYW0gZSBldmVudDogZ2V0IHZhbHVlIGJ5IGUudGFyZ2V0LnZhbHVlXG4gICAgICogQHBhcmFtIHNpZGUgbGVmdCBvciByaWdodFxuICAgICAqIEBwYXJhbSByb3cgcm93IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGRhdGUgY2xpY2tlZFxuICAgICAqIEBwYXJhbSBjb2wgY29sIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGRhdGUgY2xpY2tlZFxuICAgICAqL1xuICAgIGNsaWNrRGF0ZShlOiBhbnksIHNpZGU6IFNpZGVFbnVtLCByb3c6IG51bWJlciwgY29sOiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqICBDbGljayBvbiB0aGUgY3VzdG9tIHJhbmdlXG4gICAgICogQHBhcmFtIGU6IEV2ZW50XG4gICAgICogQHBhcmFtIGxhYmVsXG4gICAgICovXG4gICAgY2xpY2tSYW5nZShlOiBhbnksIGxhYmVsOiBhbnkpOiB2b2lkO1xuICAgIHNob3coZT86IGFueSk6IHZvaWQ7XG4gICAgaGlkZShlPzogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgY2xpY2sgb24gYWxsIGVsZW1lbnQgaW4gdGhlIGNvbXBvbmVudCwgdXNlZnVsIGZvciBvdXRzaWRlIG9mIGNsaWNrXG4gICAgICogQHBhcmFtIGUgZXZlbnRcbiAgICAgKi9cbiAgICBoYW5kbGVJbnRlcm5hbENsaWNrKGU6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBsb2NhbGUgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBsb2NhbGVcbiAgICAgKi9cbiAgICB1cGRhdGVMb2NhbGUobG9jYWxlOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqICBjbGVhciB0aGUgZGF0ZXJhbmdlIHBpY2tlclxuICAgICAqL1xuICAgIGNsZWFyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRmluZCBvdXQgaWYgdGhlIHNlbGVjdGVkIHJhbmdlIHNob3VsZCBiZSBkaXNhYmxlZCBpZiBpdCBkb2Vzbid0XG4gICAgICogZml0IGludG8gbWluRGF0ZSBhbmQgbWF4RGF0ZSBsaW1pdGF0aW9ucy5cbiAgICAgKi9cbiAgICBkaXNhYmxlUmFuZ2UocmFuZ2U6IGFueSk6IGFueTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIGFkZCB0aW1lXG4gICAgICogQHBhcmFtIHNpZGUgbGVmdCBvciByaWdodFxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldERhdGVXaXRoVGltZTtcbiAgICAvKipcbiAgICAgKiAgYnVpbGQgdGhlIGxvY2FsZSBjb25maWdcbiAgICAgKi9cbiAgICBwcml2YXRlIF9idWlsZExvY2FsZTtcbiAgICBwcml2YXRlIF9idWlsZENlbGxzO1xuICAgIC8qKlxuICAgICAqIEZpbmQgb3V0IGlmIHRoZSBjdXJyZW50IGNhbGVuZGFyIHJvdyBoYXMgY3VycmVudCBtb250aCBkYXlzXG4gICAgICogKGFzIG9wcG9zZWQgdG8gY29uc2lzdGluZyBvZiBvbmx5IHByZXZpb3VzL25leHQgbW9udGggZGF5cylcbiAgICAgKi9cbiAgICBoYXNDdXJyZW50TW9udGhEYXlzKGN1cnJlbnRNb250aDogYW55LCByb3c6IGFueSk6IGJvb2xlYW47XG59XG4iXX0=